%% For double-blind review submission
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{agda}
\usepackage{todonotes}
\usepackage{catchfilebetweentags}

\DeclareUnicodeCharacter{8759}{:\,:}
\DeclareUnicodeCharacter{954}{$\kappa$}

\newcommand{\shgrab}[1]{\medskip\ExecuteMetaData[parser.tex]{#1}}
\newcommand{\hgrab}[1]{\ExecuteMetaData[parser.tex]{#1}}

\newcommand{\sagrab}[2]{\medskip\ExecuteMetaData[#1.tex]{#2}}
\newcommand{\agrab}[2]{\ExecuteMetaData[#1.tex]{#2}}
\newcommand{\BOX}{\AR{□}}

\input{commands.tex}
\input{lhs2tex-prelude.tex}

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations



\newcommand{\parser}[1]{\textit{#1}}
\newcommand{\type}[1]{\texttt{#1}}

\begin{document}

%% Title information
\title{agdarsec -- Total Parser Combinators}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Guillaume Allais}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
  \department{Digital Security}              %% \department is recommended
  \institution{Radboud University}            %% \institution is required
%  \streetaddress{Street1 Address1}
  \city{Nijmegen}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{The Netherlands}
}
\email{gallais@cs.ru.nl}          %% \email is recommended

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
% \thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Parser combinator libraries represent parsers as functions and,
using higher-order functions, define a DSL of combinators allowing
users to quickly put together programs capable of handling complex
recursive grammars. When moving to total functional languages such
as Agda, these programs cannot be directly ported: there is nothing
in the original definitions guaranteeing termination.

In this paper, we will introduce a `guarded' modal operator acting
on types and show how it allows us to give more precise types to
existing combinators thus guaranteeing totality. The resulting
library is available online together with various usage examples
at \url{https://github.com/gallais/agdarsec}.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
\end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Parser Combinators, Agda, Total Programming}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Parser combinators have made functional languages such as Haskell
shine. They are a prime example of the advantages Embedded Domain
Specific Languages provide the end user. She not only has access
to a library of powerful and composable abstractions but she is also
able to rely on the host language's existing tooling and libraries.
She also gets feedback from the static analyses built in the compiler
(e.g. type and coverage checking) and can exploit the expressivity
of the host language to write generic parsers thanks to polymorphism
and higher order functions.

However she only gets the guarantees the host language is willing
to give. In non-total programming languages such as Haskell this
means she will not be prevented from writing parsers which will
unexpectedly fail on some (or even all!) inputs. Handling a
left-recursive grammar is perhaps the most iconic pitfall leading
beginners to their doom: a parser never making any progress.

We start with a primer on parser combinators and follow up with the
definition of a broken parser which is silently accepted by Haskell.
We then move on to Agda~\cite{norell2009dependently} and introduce combinators to
define functions by well-founded recursion. This allows us to define
a more informative notion of parser and give more precise types to
the combinators commonly used. We then demonstrate that broken parsers
such as the one presented earlier are rejected whilst typical example
can be ported with minimal modifications.

\section{A Primer on Parser Combinators}

\subsection{Parser Type}

Let us start by reminding ourselves what a parser is. Although we
will eventually move to a more generic type, Fritz Ruehr's rhyme
gives us the \emph{essence} of parsers:

\begin{verse}
  A Parser for Things\\
  is a function from Strings\\
  to Lists of Pairs\\
  of Things and Strings!
\end{verse}

This stanza directly translates to the following Haskell type (we
use a \textbf{newtype} wrapper to have cleaner error messages):

\shgrab{parser}

It is naturally possible to run such a parser and try to extract
a value from a successful parse. Opinions may vary on whether a
run with leftover characters can be considered successful or not.
We decide against it. This is not crucial as both styles can be
mutually emulated by either providing an 'end of file' parser
guaranteeing that only runs with no leftovers are successful or
by extending a grammar with a dummy case consuming the rest of
the input string.

\shgrab{parse}

\subsection{(Strongly-Typed) Combinators}

The most basic parser is the one that accepts any character.
It succeeds as long as the input string is non empty and
returns one result: the tail of the string together with the
character it just read.

\shgrab{anychar}

However what makes parsers interesting is that they recognize
structure. As such, they need to reject invalid inputs. The
parser only accepting decimal digit is a bare bones example.
It can be implemented in terms of \parser{guard}, a higher
order parser checking that the value returned by its argument
abides by a predicate which can easily be implemented using
functions from the standard library.

\shgrab{guard}
\hgrab{digit}

These two definitions are only somewhat satisfactory: the
resut of the \parser{digit} parser is still \emph{stringly-typed}.
Instead of using a predicate to decide whether to keep the
value, we can opt for a validation function of type
\mbox{\textit{a → Maybe b}} which returns
a witness whenever the check succeeds. To define this
alternative \parser{guardM} we can once more rely on code
already part of the standard library.

In our concrete example of recognizing a digit, we want to
return an \type{Int} corresponding to it. Once more the
standard library has just the right function to use together
with \parser{guardM}.

\shgrab{guard2}
\hgrab{digit2}

\subsection{Code Reuse: Recognizing Structures}

We have seen how we can already rely on the standard library
of the host language to seemlessly implement combinators.
We can leverage even more of the existing codebase by noticing
that the type constructor \type{Parser} is a \type{Functor},
an \type{Applicative}~\cite{mcbride2008applicative}, a \type{Monad} and also an \type{Alternative}.

% insert alternative instance
% interesting use case? replicateM?

\subsection{Expressivity: Higher Order Parsers and Fixpoints}

Our first example of a higher order parser was \parser{guardM}
which takes as arguments a validation function as well as another
parser and produces a parser for the type of witnesses returned
by the validation function.

The two parsers \AB{some} and \AB{many} turn a parser for elements
into ones for non-empty and potentially empty lists of such elements
respectively. They concisely showcase the power of mutual recursion,
higher-order functions and the \type{Functor}, \type{Applicative},
and \type{Alternative} structure.

\shgrab{some}
\hgrab{many}

\remark{Non-Commutativity} The disjunction combinator is
non-commutative. As such the definitions of \textit{some} and
\textit{many} will try to produce the longest list as possible
as opposed to a flipped version of \text{many} which would start
by returning the empty list and slowly offer longer and longer
matches.


\section{The Issue with Haskell's Parser Types}\label{sec:haskellproblem}

The ability to parse recursive grammars by simply declaring
them in a recursive manner is however dangerous: unlike type
errors which are caught by the typechecker and partial covers
in pattern matchings which are detected by the coverage checker,
termination is not guaranteed here.

The problem already shows up in the definition of \parser{some}
which will only make progress if its argument actually uses up
part of the input string. Otherwise it may loop. However this
is not the typical hurdle programmers stumble upon: demanding
a non empty list of nothing at all is after all rather silly.
The issue manifests itself naturally whenever defining a left
recursive grammar which leads us to introducing the prototypical
such example: \type{Expr}, a minimal language of arithmetic
expressions.

\[
\texttt{Expr} ~::=~ \texttt{<Int>} ~|~ \texttt{<Expr>} ~\text{`+`}~ \texttt{<Expr>}
\]

The intuitive solution is to simply reproduce this definition by
introducing an inductive type for \type{Expr} and then defining
the parser as an alternative between a literal on one hand and a
sub-expression, the character '+', and another sub-expression on
the other.

\shgrab{Expr}
\hgrab{expr}

However this leads to an infinite loop. Indeed, the second
alternative performs a recursive call to \parser{expr} even
though it hasn't consumed any character from the input string.

The typical solution to this problem is to introduce two 'tiers'
of expressions: the \parser{base} ones which can only be whole
expressions if we consume an opening parenthesis first and the
\parser{expr'} ones which are left-associated chains of \parser{base}
expressions connected by '+'.

\shgrab{base}
\hgrab{expr2}

This approach can be generalised when defining more complex
languages by having even more tiers, one for each
\emph{fixity level}, see for instance~\ref{example:expr}.
An extended language of arithmetic expressions would for
instance distinguish the level at which addition and
substraction live from the one at which multiplication and
division do.


Our issue with this solution is twofold. Firt, although we did
eventually managed to build a parser that worked as expected,
the compiler was unable to warn us and guide us towards this
correct solution. Additionnally, the blatant partiality of
some of these definitions means that these combinators and
these types are wholly unsuitable in a total setting. We could, of
course use an escape hatch and implement our parsers in Haskell
but that would both be unsafe and mean we would not be able
to run them at typechecking time which we may want to do if
we embed checked examples in our software's documentation,
or use constant values (e.g. filepaths).

\section{Indexed Sets and Course-of-Values Recursion}

Our implementation of Total Parser Combinators is in Agda,
a total dependently typed programming language and it will
rely heavily on indexed sets. But the indices will not be
playing any interesting role apart from enforcing totality.
As a consequence, we introduce combinators to build indexed
sets without having to mention the index explicitly. This
ought to make the types more readable by focusing on the
important components and hiding away the artefacts of the
encoding.

The first kind of combinators corresponds to operations on
sets which are lifted to indexed sets by silently propagating
the index. We only show the ones we will use in this paper:
the pointwise arrow and product types and the constant function.

\sagrab{Relation/Unary/Indexed}{arrow}
\agrab{Relation/Unary/Indexed}{product}
\agrab{Relation/Unary/Indexed}{constant}

\remark{Mixfix Operators} In Agda underscores correspond to
positions in which arguments are to be inserted. It may be a
bit surprising to see infix notations for functions taking
three arguments but they are only meant to be partially applied.
\medskip{}

The second kind of combinator turns an indexed set into a set
by universally quantifying over the index.

\sagrab{Relation/Unary/Indexed}{forall}

\remark{Implicit Arguments} We use curly braces so that the
index we use is an \emph{implicit} argument we will never
have to write: Agda will fill it in for us by unification.
\medskip{}

We can already see the benefits of using these aliases. For instance
the fairly compact expression \AF{[} (\AF{κ} \AB{P} \AF{⊗} \AB{Q}) \AF{⟶} \AB{R} \AF{]}
corresponds to the more verbose type
\AS{∀} \{\AB{n}\} \AS{→} (\AB{P} \AF{×} \AB{Q} \AB{n}) \AS{→} \AB{R} \AB{n}.


Last but not least, the \BOX{} type constructor takes a \AD{ℕ}-indexed
set and produces the set of valid recursive calls for a function defined
by course-of-values recursion: \BOX{} \AB{A} \AB{n} associates to each
\AB{m} strictly smaller than \AB{n} a value of type \AB{A} \AB{m}.
This construct, analogous to the later modality showing up in Guarded
Type Theory~\cite{vezzosi2015guarded}, empowers the user to give precise
types in a total language to programs commonly written in partial ones
(see e.g. the definition of \textit{fix} below).

\sagrab{Induction/Nat/Strong}{box}

\remark{Record Wrapper} Instead of defining \BOX{} as a
function like the other combinators, we wrap the corresponding
function space in a record type. This prevents normalisation from
unfolding the combinator too eagerly and makes types more readable
during interactive development.

\remark{Irrelevance} The argument stating that \AB{m} is strictly
smaller than \AB{n} is preceded by a dot. In Agda, it means that
this value is irrelevant and can be erased by the compiler.
In Coq, we would define the relation \AF{\_<\_} in \type{Prop} to
achieve the same.

\medskip{}

This \BOX{} type combinator has some useful value combinators.
The first thing we can notice is the fact that \textbf{\BOX{} is a
functor}; that is to say that given a natural transformation from
\AB{A} to \AB{B}, we can define a natural transformation from
\BOX{} \AB{A} to \BOX{} \AB{B}.

\sagrab{Induction/Nat/Strong}{map}

\remark{Copatterns} The definition of \AF{map} uses
the \BOX{} field named \ARF{call} on the \emph{left hand side}.
This is a copattern~\cite{abel2013copatterns}, meaning that we
explain how the definition is \emph{observed} (via \ARF{call})
rather than \emph{constructed} (via \AIC{mkBox}).

\medskip{}

Because \AF{\_<\_} is defined in terms of \AD{\_≤\_}, \AF{≤-refl}
which is the proof that \AD{\_≤\_} is reflexive is also a proof
that any \AB{n} is strictly smaller than \AN{1} \AF{+} \AB{n}.
We can use this fact to write the following \AF{extract} function:

\sagrab{Induction/Nat/Strong}{extract}

\remark{Counit} The careful reader will have noticed
that this is not quite the \textit{extract} we would expect from a
comonad: for a counit, we would need a natural transformation
between \BOX{} \AB{A} and \AB{A} i.e. a function of type
\mbox{\AF{[} \BOX{} \AB{A} \AF{⟶} \AB{A} \AF{]}}. We will not be able
to define such a function: \BOX{} \AB{A} \AN{0} is isomorphic to
the unit type so we would have to generate an \AB{A} \AN{0} out
of thin air. The types \AB{A} for which \BOX{} has a counit are
interesting in their own right: they are inhabited at every single
index as demonstrated by \AF{fix} later on.

\medskip{}

Even though we cannot have a counit, we are still able to define
a comultiplication thanks to the fact that \AF{\_<\_} is transitive.

\sagrab{Induction/Nat/Strong}{duplicate}

\remark{Identifiers in Agda} Any space-free string which
is not a reserved keyword is a valid identifier. As a consequence
we can pick suggestive names such as \AB{m<n} for a proof that $m < n$
(notice the extra spaces around the infix operator $(<)$).

\medskip{}

Exploring further the structure of the functor \BOX{}, we can observe
that just like it is not quite a comonad, it is not quite an applicative
functor. Indeed we can only define \AB{pure}, a natural transformation
of type \mbox{\AF{[} \AB{A} \AF{⟶} \AR{\BOX{}} \AB{A} \AF{]}}, for the types \AB{A}
that are downwards closed. Providing the user with \AB{app} is however
possible:

\agrab{Induction/Nat/Strong}{app}

Finally, we can reach what will serve as the backbone of our parser
definitions: a safe, total fixpoint combinator. It differs from the
traditional $Y$ combinator in that all the recursive calls have to be
guarded.

\sagrab{Induction/Nat/Strong}{fix}

If we were to unfold all the type-level combinators and record wrappers,
the type of \AF{fix} would correspond exactly to strong induction for
the natural numbers. Hence its implementation also follows the one of strong
induction: it is a combination of a call to \AF{extract} and an auxiliary
definition \AF{fix\BOX{}} of type \mbox{\AF{[} \AR{\BOX{}} \AB{A} \AF{⟶}
\AB{A} \AF{]} \AS{→} \AF{[} \AR{\BOX} \AB{A} \AF{]}}.

\remark{Generalisation}  A similar \BOX{}
type constructor can be defined for any induction principle relying
on an accessibility predicate. Which means that a library's types
can be cleaned up by using these combinators in any situation where
one had to give up structural induction for a more powerful alternative.

\section{Parsing, Totally}

As already highlighted in Section~\ref{sec:haskellproblem}, \AB{some}
and \AB{many} can yield diverging computations if the parser they are
given as an argument succeeds on the empty string. To avoid any such
issue, we adopt a radical solution: for a parser's run to be considered
successful, it must have consumed some of its input.

This can be made formal with the \AR{Success} record type: a \AF{Success}
of type \AB{A} and size {n} is a value of type \AB{A} together with the
leftovers of the input string of size strictly smaller than \AB{n}.

\agrab{Text/Parser/Success}{success}

\remark{Implicit Field} Just like the arguments to a function can be
implicit, so can a record's fields. The user can then leave them out
when building a value and they will be filled in by unification.

\medskip{}

Coming back to Fritz Ruehr's rhyme, we can define our own \AR{Parser}
type: a parser for things up to size \AB{n} is a function from strings
of length \AB{m} less than \AB{n} to lists of \AR{Success}es of size \AB{m}.

\agrab{Text/Parser/Combinators}{parser}

Now that we have a precise definition of \AR{Parser}s, we can start
building our library of combinators. Our first example \AF{anyChar}
can be defined by copattern-matching and then case analysis on the
input string: if it is empty then the list of \AR{Success}es is also
empty, otherwise it contains exactly one element which corresponds to
the head of the input string and its tail as leftovers.

\agrab{Text/Parser/Combinators}{anyChar}

Unsurprisingly \AF{guardM} is still a valid higher-order combinator:
filtering out results which do not agree with a predicate is absolutely
compatible with the consumption constraint we have drawn. To implement
\AF{guardM} we can once more reuse existing library functions such as
\AF{gfilter} which turns a \mbox{\AD{List} \AB{A}} into a \mbox{\AD{List} \AB{B}}
provided a predicate \mbox{\AB{A} \AS{→} \AD{Maybe} \AB{B}}.

\agrab{Text/Parser/Combinators}{guardM}

Demonstrating that \AR{Parser} is a functor goes along the same
lines: using \AD{List}'s and \AR{Success}'s \AF{map}s. Similarly,
we can prove that it is an \AF{Alternative}: failing corresponds
to returning the empty list no matter what whilst disjunction is
implemented using concatenation.

\agrab{Text/Parser/Combinators}{fmap}\vspace*{-2em}
\agrab{Text/Parser/Combinators}{fail}\vspace*{-2em}
\agrab{Text/Parser/Combinators}{disjunction}

So far the types we have ascribed to our combinators are, if we ignore
the $\mathbb{N}$ indices, exactly the
same as the ones one would find in any other parsec library. In none
of the previous combinators do we run a second parser on the leftovers
of a first one. All we do is either manipulate or combine the results
of one or more parsers run in parallel, potentially discarding some of
these results on the way.

However when we run a parser \emph{after} some of the input has already
been consumed, we could safely perform a \emph{guarded} call. This being
made explicit would be useful when using \AF{fix} to define a parser for
a recursive grammar. Luckily \AR{Parser} is, by definition, a
downwards-closed type. This means that we may use very precise types marking
all the guarded positions with \BOX{}; if the user doesn't need that extra
power she can very easily bypass the \BOX{} annotations by using \AF{box}:

\agrab{Text/Parser/Combinators}{box}

The most basic example we can give of such an annotation is probably the
definition of a conjunction combinator \AF{\_<\&>\_} taking two parsers,
running them sequentially and returning a pair of their results. The second
parser is given the type \mbox{\BOX{} \AR{Parser} \AB{B}} instead of
\mbox{\AR{Parser} \AB{B}} which we would expect to find in other parsec libraries.

\agrab{Text/Parser/Combinators}{conjunction}

We can immediately use all of these newly-defined combinators to give
a safe, total definition of \AF{some} which takes a parser for \AB{A}
and returns a parser for non-empty lists of \AB{A}s. It is defined as
a fixpoint and proceeds as follows: it either combines a head and a
non-empty tail using \AF{$\_::^{+}\_$} or returns a singleton list.

\agrab{Text/Parser/Combinators}{badsome}

\remark{Inefficiency} Unfortunately this definition is inefficient.
Indeed, in the base case \mbox{\AF{some} \AB{p}} is going to run the parser
\AB{p} twice: once in the first branch before realising that \AB{rec}
fails and once again in the second branch. Compare this definition to
the Haskell version (after inlining \AB{many}) where \AB{p} is run once
and then its result is either combined with a list obtained by recursion
or returned as a singleton:

\shgrab{some2}

This inefficiency can be fixed by using a notion of conjunction
\AF{\_<\&?>\_} which allows the second parser to fail whilst still
producing a successful run. The parser \mbox{\AF{some} \AB{p}} can then be
defined as the conjunction of \AB{p} and a potentially failing
recursive call. The function \AF{cons} (whose definition we omit here)
either uses \AF{$\_::^{+}\_$} to put the head and the non-empty
tail together or returns a singleton list if the recursive call
failed.

\agrab{Text/Parser/Combinators}{conjunction2}
\agrab{Text/Parser/Combinators}{goodsome}

\remark{Non-compositionality} The higher-order parser \AF{some}
expects a \emph{fully} defined parser as an argument. This makes
it impossible to use it as one of the building blocks of a larger,
recursive parser. Ideally we would rather have a combinator of
type \mbox{\AF{[} \AF{Parser} \AB{A} \AF{⟶} \AF{Parser} (\AF{List$^+$} \AB{A}) \AF{]}}.
This will be adressed in the next subsection.
\medskip{}

As the previous code snippet shows, \AF{\_<\&?>\_} is defined in
terms of a more fundamental notion \AF{\_\&?>>=\_} which is a
combinator analogous to a monad's \textit{bind}. On top of running
two parsers sequentially (with the second one being chosen based on
the result obtained by running the first), it allows the second one to fail
and returns both results.

\agrab{Text/Parser/Combinators}{mbind}

This crucial definition makes it possible to port a lot of the Haskell
definitions where one would use a parser which does not use any of its
input. And this is possible without incurring any additional cost as
the optimised version of \AF{some} showed.

\subsection{Left and Right Chains}

The pattern used in the solution presented in Section~\ref{sec:haskellproblem}
can be abstracted with the notion of an (heterogeneous) left chain which takes
a parser for a seed, one for a constructor, and one for and argument. The crucial
thing is to make sure \emph{not} to use the parser one is currently defining as
the seed.

\shgrab{hchainl}

We naturally want to include a safe variant of this combinator in our
library. However this definition relies on the ability to simply use
\textit{return} in case it's not possible to parse an constructor
additional constructor and argument and that is something we simply
don't have access to.

\subsection{Examples}

\todo{expr}\label{example:expr}

%% Acknowledgments
%\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
%  This material is based upon work supported by the
%  \grantsponsor{GS100000001}{National Science
%    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%  conclusions or recommendations expressed in this material are those
%  of the author and do not necessarily reflect the views of the
%  National Science Foundation.
%\end{acks}


%% Bibliography
\bibliography{main.bib}


%% Appendix
%\appendix
%\section{Appendix}


\end{document}
